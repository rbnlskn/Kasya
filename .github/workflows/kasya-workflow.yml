name: Kasya Workflow Automation

on:
  # 1. Manual Trigger with Input (Forcing it to run on specific issue)
  workflow_dispatch:
    inputs:
      debug_issue_number:
        description: 'Issue Number to Test (e.g., 40)'
        required: true
        default: '40'
  # 2. Automatic Triggers
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]
  issue_reaction:
    types: [created]
  pull_request:
    types: [closed]

permissions:
  issues: write
  pull-requests: read
  contents: write

jobs:
  # ------------------------------------------------------------------
  # THE MANAGER JOB (Runs on EVERY event, filters inside steps)
  # ------------------------------------------------------------------
  kasya_manager:
    runs-on: ubuntu-latest
    steps:
      # STEP 1: Debug Log (This will ALWAYS run, proving the file works)
      - name: ðŸ” Diagnostic Log
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Action: ${{ github.event.action }}"
          echo "Actor: ${{ github.actor }}"

      # STEP 2: Logic Router (Decides what to do based on the event)
      - name: ðŸ§  Router & Execution
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.JULES_PAT }}
          script: |
            // ---------------- INITIALIZATION ----------------
            const event = context.eventName;
            const payload = context.payload;
            let issueNumber = null;
            let triggerType = null;

            // DETERMINE CONTEXT BASED ON EVENT
            if (event === 'workflow_dispatch') {
              issueNumber = parseInt('${{ inputs.debug_issue_number }}');
              console.log(`ðŸ”§ MANUAL DEBUG MODE: Targeting Issue #${issueNumber}`);
              triggerType = 'ACTIVATE'; // Manual runs force activation
            } 
            else if (event === 'issues') {
              issueNumber = context.issue.number;
              const labels = payload.issue.labels || [];
              const hasReady = labels.some(l => l.name === 'ready');
              
              if (hasReady) {
                 console.log(`âœ… Issue #${issueNumber} has 'ready' label. Activating.`);
                 triggerType = 'ACTIVATE';
              } else {
                 console.log(`â„¹ï¸ Issue #${issueNumber} does NOT have 'ready' label. Ignoring.`);
                 return; // EXIT SCRIPT
              }
            }
            else if (event === 'issue_reaction' && payload.reaction.content === '+1') {
               issueNumber = context.issue.number;
               triggerType = 'APPROVE_PLAN';
            }
            else if (event === 'issue_comment') {
               issueNumber = context.issue.number;
               if (payload.comment.user.login.toLowerCase().includes('jules')) {
                 triggerType = 'UPDATE_STATUS';
               }
            }
            else if (event === 'pull_request' && payload.pull_request.merged === true) {
               triggerType = 'CLOSE_MERGE';
            }

            if (!triggerType) {
              console.log("â›” No matching logic for this event. Stopping.");
              return;
            }

            // ---------------- LOGIC HANDLERS ----------------
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // HANDLER 1: ACTIVATION (Ready -> Jules)
            if (triggerType === 'ACTIVATE') {
              console.log(`ðŸš€ Starting ACTIVATION for Issue #${issueNumber}`);

              // Cleanup Labels
              const labelsToRemove = ['backlog', 'ready'];
              for (const name of labelsToRemove) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name }); } catch (e) {} 
              }
              
              // Assign User
              try {
                await github.rest.issues.addAssignees({ owner, repo, issue_number: issueNumber, assignees: [context.actor] });
              } catch (e) { console.log("Could not assign user: " + e.message); }

              // Build Context
              const issue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
              const body = issue.data.body || "";
              // Regex to find #123
              const matches = [...body.matchAll(/#(\d+)/g)];
              
              let contextContent = "\n\n---\n# ðŸ§  CONSOLIDATED CONTEXT\n> **System Note:** Merged content from sub-issues.\n\n";

              if (matches.length > 0) {
                for (const match of matches) {
                  const subIssueNum = parseInt(match[1]);
                  console.log(`Processing sub-issue #${subIssueNum}`);

                  try {
                    // Add 'in progress' to sub-issue
                    await github.rest.issues.addLabels({ owner, repo, issue_number: subIssueNum, labels: ['in progress'] });

                    // Fetch sub-issue content
                    const subIssue = await github.rest.issues.get({ owner, repo, issue_number: subIssueNum });
                    contextContent += `### Sub-Issue #${subIssueNum}: ${subIssue.data.title}\n${subIssue.data.body}\n\n`;
                  } catch (err) {
                    console.log(`Failed to process sub-issue #${subIssueNum}: ${err.message}`);
                  }
                }
              } else {
                contextContent += "No sub-issues found in description.";
              }

              // Update Main Issue with Context
              const newBody = body + contextContent;
              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body: newBody });

              // Add Labels to Main Issue (Triggers Agent)
              await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: ['planning', 'jules'] });
            }

            // HANDLER 2: APPROVE PLAN (User +1 -> Execution)
            else if (triggerType === 'APPROVE_PLAN') {
               console.log(`ðŸ‘ Approval detected on Issue #${issueNumber}`);
               try {
                 const issue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                 const hasPlanning = issue.data.labels.some(l => l.name === 'planning');

                 if (hasPlanning) {
                   console.log("Transitioning from PLANNING to EXECUTION.");
                   await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: 'planning' });
                   await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: ['in progress', 'jules'] });
                 } else {
                   console.log("Issue is not in PLANNING state. Ignoring approval.");
                 }
               } catch (e) {
                 console.log(`Error in APPROVE_PLAN: ${e.message}`);
               }
            }

            // HANDLER 3: UPDATE STATUS (Jules Comment)
            else if (triggerType === 'UPDATE_STATUS') {
              console.log("ðŸ“ Status update from Jules detected.");
              // Placeholder: Could update a project board or log metrics
            }

            // HANDLER 4: CLOSE MERGE (PR Merged -> Close Issues)
            else if (triggerType === 'CLOSE_MERGE') {
              console.log("ðŸŽ‰ PR Merged. Attempting to close linked issues.");
              const prBody = payload.pull_request.body || "";
              // Find "Fixes #123", "Closes #123", or just "#123" if that's the convention
              // Using a broad regex for numbers mentioned
              const matches = [...prBody.matchAll(/#(\d+)/g)];

              for (const match of matches) {
                const num = parseInt(match[1]);
                try {
                  console.log(`Closing issue #${num}`);
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'closed' });
                } catch (e) {
                  console.log(`Could not close issue #${num}: ${e.message}`);
                }
              }
            }
