name: Kasya Workflow Automation

on:
  # 1. Manual Trigger with Input (Forcing it to run on specific issue)
  workflow_dispatch:
    inputs:
      debug_issue_number:
        description: 'Issue Number to Test (e.g., 40)'
        required: true
        default: '40'
  # 2. Automatic Triggers
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]
  issue_reaction:
    types: [created]
  pull_request:
    types: [closed]

permissions:
  issues: write
  pull-requests: read
  contents: write

jobs:
  # ------------------------------------------------------------------
  # THE MANAGER JOB (Runs on EVERY event, filters inside steps)
  # ------------------------------------------------------------------
  kasya_manager:
    runs-on: ubuntu-latest
    steps:
      # STEP 1: Debug Log
      - name: ðŸ” Diagnostic Log
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Action: ${{ github.event.action }}"
          echo "Actor: ${{ github.actor }}"

      # STEP 2: Logic Router
      - name: ðŸ§  Router & Execution
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.JULES_PAT }}
          script: |
            // ---------------- INITIALIZATION ----------------
            const event = context.eventName;
            const payload = context.payload;
            let issueNumber = null;
            let triggerType = null;

            // DETERMINE CONTEXT BASED ON EVENT
            if (event === 'workflow_dispatch') {
              issueNumber = parseInt('${{ inputs.debug_issue_number }}');
              console.log(`ðŸ”§ MANUAL DEBUG MODE: Targeting Issue #${issueNumber}`);
              triggerType = 'ACTIVATE'; 
            } 
            else if (event === 'issues') {
              issueNumber = context.issue.number;
              const labels = payload.issue.labels || [];
              const hasReady = labels.some(l => l.name === 'ready');
              
              if (hasReady) {
                 console.log(`âœ… Issue #${issueNumber} has 'ready' label. Activating.`);
                 triggerType = 'ACTIVATE';
              } else {
                 console.log(`â„¹ï¸ Issue #${issueNumber} does NOT have 'ready' label. Ignoring.`);
                 return; 
              }
            }
            else if (event === 'issue_reaction' && payload.reaction.content === '+1') {
               issueNumber = context.issue.number;
               triggerType = 'APPROVE_PLAN';
            }
            else if (event === 'issue_comment') {
               issueNumber = context.issue.number;
               if (payload.comment.user.login.toLowerCase().includes('jules')) {
                 triggerType = 'UPDATE_STATUS';
               }
            }
            else if (event === 'pull_request' && payload.pull_request.merged === true) {
               triggerType = 'CLOSE_MERGE';
            }

            if (!triggerType) {
              console.log("â›” No matching logic for this event. Stopping.");
              return;
            }

            // ---------------- LOGIC HANDLERS ----------------
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // HANDLER 1: ACTIVATION (Ready -> Jules)
            if (triggerType === 'ACTIVATE') {
              // Cleanup Labels
              const labelsToRemove = ['backlog', 'ready'];
              for (const name of labelsToRemove) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name }); } catch (e) {} 
              }
              
              // Assign User
              await github.rest.issues.addAssignees({ owner, repo, issue_number: issueNumber, assignees: [context.actor] });

              // Build Context
              const issue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
              const body = issue.data.body || "";
              const matches = [...body.matchAll(/#(\d+)/g)];
              
              let contextContent = "\n\n---\n# ðŸ§  CONSOLIDATED CONTEXT\n> **System Note:** Merged content from sub-issues.\n\n";

              if (matches.length > 0) {
                // Add temp context label
                await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: ['context'] });
                
                for (const match of matches) {
                  const subId = parseInt(match[1]);
                  if (subId === issueNumber) continue;
                  try {
                    const subIssue = await github.rest.issues.get({ owner, repo, issue_number: subId });
                    
                    // Update sub-issue status
                    try { await github.rest.issues.removeLabel({ owner, repo, issue_number: subId, name: 'backlog' }); } catch(e){}
                    await github.rest.issues.addLabels({ owner, repo, issue_number: subId, labels: ['in progress'] });
                    
                    contextContent += `## ðŸ“„ Sub-Issue #${subId}: ${subIssue.data.title}\n${subIssue.data.body}\n\n---\n`;
                  } catch (e) {}
                }
              }

              // Update Batch Body & Add Final Labels
              await github.rest.issues.update({ owner, repo, issue_number: issueNumber, body: body + contextContent });
              try { await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: 'context' }); } catch(e){}
              
              await github.rest.issues.addLabels({ 
                owner, repo, issue_number: issueNumber, 
                labels: ['jules', 'planning'] 
              });
              console.log("ðŸŽ‰ Activation Complete: Jules triggered in Planning mode.");
            }

            // HANDLER 2: PLAN APPROVAL (Reaction -> Execution)
            if (triggerType === 'APPROVE_PLAN') {
               const issue = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
               const labels = issue.data.labels.map(l => l.name);
               
               if (labels.includes('planning')) {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: 'planning' });
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: ['in progress', 'jules'] });
                  await github.rest.issues.createComment({
                    owner, repo, issue_number: issueNumber,
                    body: "ðŸ‘ **Plan Approved.** Jules is starting execution now."
                  });
                  console.log("âœ… Plan Approved. Switched to Execution.");
               } else {
                  console.log("Reaction detected, but issue was not in 'planning' mode.");
               }
            }

            // HANDLER 3: STATUS UPDATE (Jules Comment -> Review)
            if (triggerType === 'UPDATE_STATUS') {
               const body = payload.comment.body.toLowerCase();
               if (body.includes('pull request') || body.includes('/pull/')) {
                  try { await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: 'in progress' }); } catch(e){}
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: ['in review'] });
                  console.log("ðŸ‘€ PR detected. Moved to Review.");
               }
            }

            // HANDLER 4: CLOSE ON MERGE
            if (triggerType === 'CLOSE_MERGE') {
               const pr = payload.pull_request;
               const prBody = pr.body || "";
               const matches = [...prBody.matchAll(/#(\d+)/g)];

               for (const match of matches) {
                  const batchId = parseInt(match[1]);
                  console.log(`Closing Batch #${batchId}`);
                  
                  try { await github.rest.issues.removeLabel({ owner, repo, issue_number: batchId, name: 'in review' }); } catch(e){}
                  await github.rest.issues.addLabels({ owner, repo, issue_number: batchId, labels: ['completed'] });
                  await github.rest.issues.update({ owner, repo, issue_number: batchId, state: 'closed' });

                  const batchIssue = await github.rest.issues.get({ owner, repo, issue_number: batchId });
                  const subMatches = [...(batchIssue.data.body || "").matchAll(/#(\d+)/g)];
                  for (const sub of subMatches) {
                     const subId = parseInt(sub[1]);
                     if (subId === batchId) continue;
                     try {
                        try { await github.rest.issues.removeLabel({ owner, repo, issue_number: subId, name: 'in progress' }); } catch(e){}
                        await github.rest.issues.addLabels({ owner, repo, issue_number: subId, labels: ['completed'] });
                        await github.rest.issues.update({ owner, repo, issue_number: subId, state: 'closed' });
                     } catch(err) {}
                  }
               }
            }
